---
title: 'Git-command'
date: 2024-07-01
permalink: /posts/2024/07/FullStackEngneering/
tags:
  - Notes
---

About Full Stack Engineers

# Intro

* 全栈的出现：web技术的发展和自然而然引发的分工。【A full stack web developer is someone that does design, markup, styling, behavior, and programming.】
* 全栈不是全能，**广泛的 Web 技术（包括网络、前端、后端 MVC、持久化技术等多个层次。）才是一名通常意义上的全栈工程师最该专注的核心内容**

# HTTP protocol history

## http/0.9

* 1991 年，HTTP 在最开始的 0.9 版就定义了协议最核心的内容，从功能上看只是具备了如今内容的一个小小的子集。
* 它非常简单，不支持请求正文，不支持除了 GET 以外的其它方法，不支持头部，甚至没有版本号的显式指定，而且整个请求只有一行，因而也被称为“The One-line Protocol”。比如：GET /target.html.

## http/1.0

*  1996 年，HTTP 1.0 版本就稳定而成熟了，也是如今浏览器广泛支持的**最低版本 HTTP 协议**。
* 引入了返回码，引入了 header，引入了多字符集，也终于支持多行请求了。方法只支持 GET、HEAD、POST 这几个。
* 每一组请求和响应的交互，都需要完成一次TCP的连接和关闭操作，在使用频率较低时没有暴露多大问题。
* 第一个具备广泛实际应用价值的协议版本。

## http/1.1--目前最广泛的协议

* 1999 年，著名的 RFC2616，在 1.0 的基础上，大量帮助传输效率提升的特性被加入。
* 从网络协议分层上看， TCP 协议在 HTTP 协议的下方（TCP 是在 OSI 7 层协议的第 4 层，而 HTTP 则是在最高的第 7 层应用层，因此，前者更加“底层”一点）。
* 采用**http长连接**：避免http1.0时候，每一组请求和响应的交互都需要完成一次TCP的连接和关闭操作。【长连接：打开一次TCP连接，可以被连续几次报文传输重用，减少资源占用和重复。】

* 长连接开启的情况下，使用content-length or Chunked 头。【Chunked头分块传输编码大大提高了HTTP交互的灵活性。】
* 其他: 更全面的方法、更全面的返回码、对指定客户端缓存策略的支持、对content negotiation的支持等。

## http/2

* 在http/1.1的基础上，保持兼容性的前提下包含以下重要改进：
  - ALPN机制: 允许客户端来选择使用的 HTTP 版本。
  - 支持HTTP 头的压缩：在 HTTP/2 以前，HTTP 正文支持多种方式的压缩，但是 HTTP 头部却不能。
  - 支持多路复用：允许客户端同时在一个连接中同时传输多组请求响应的方法。
  - 服务端将网页必要资源一次性 push 到客户端，而不是每次客户端确认缺什么再来索取，节约加载时间。

# HTTPS

* https出现的原因---基于http无法满足复杂的需求：数据加密传输的安全性需求、服务器消息即时推送的交互模式需求等。【因此，需要引入其他协议来：增强、填补HTTP协议所不擅长的空白领域；】

## SSL（Secure Socket Layer）/TLS（Transport Layer Security）

* 解决HTTP明文传输过程中存在的：拦截、伪装、篡改问题。
* HTTP + SSL/TLS = HTTPS
* 事实上一开始只有SSL，后来在SSL3.0之后，其被标准化并通过RFC2246以SSL为基础建立了TLS的第一个版本。

## 对称性和非对称性加密

* 对称性Symmetric Cryptograph：加解密使用相同的密钥。
  * 优点：简单、加解密速度快。
  * 缺点：加解密使用相同密钥，如何安全传递密钥是一个问题。
* 非对称性加密Asymmetric Cryptograph：数据加解密使用不同的密钥---**公钥public Key+私钥 private Key**。
  * 公钥、私钥同时生成：公钥可以公开和传播，私钥不能。
  * 经过公钥加密的数据需要私钥才能解密，反之亦然。
* 性能较差，但加解密的密钥相对独立，可以放心传播。

## TLS 连接建立原理

**TLS通过非对称加密技术来保证握手过程的可靠性；通过对称加密技术来保证传输过程的可靠性。**[how https works](https://howhttps.works/)

* step1-Client Hello：客户端向服务端打招呼，并携带信息：**客户端产生的随机数A**、**客户端支持的加密方法列表**。

* step2-Server Hello：服务端向客户端回复，并携带信息：**服务端产生的随机数B**、**服务端根据客户端的支持情况确定出的加密方法组合Cipher Suite。**

* step3-Certificate，Server Key Exchange，Server Hello Done：服务端在打完招呼之后紧接着告知：

  * Certificate，证书信息（包含服务端生成的公钥）。
  * 客户端收到信息，验证证书有效后，公钥也就同样可信。接着客户端再生成一个**随机数C**（Pre-master Secret），此时共有的随机数A、B、C根据约好的加密方法组合生成**新的密钥X（Master Secret）**而由 X 可继续生成真正用于后续数据进行加密和解密的对称密钥。因为它是在本次 TLS 会话中生成的，所以也被称为会话密钥（Session Secret）。简言之：
    * 客户端随机数 A + 服务端随机数 B + 客户端 Pre-master Secret C → 会话密钥

* Step4-Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message：接着客户端告诉服务端：

  - Client Key Exchange，本质上它就是上面说的这个 C，但使用了**服务端通过证书发来的公钥加密（上面是客户端发来的证书）**；
  - Change Cipher Spec，客户端同意正式启用约好的加密方法和密钥了，后面的数据传输全部都使用密钥 X 来加密；
  - Encrypted Handshake Message，快速验证：这是客户端对于整个对话进行摘要并加密得到的串，如果经过服务端解密，和原串相等，就证明整个握手过程是成功的。

  服务端收到消息后，用自己私钥解密上面的 Client Key Exchange，得到了 C，这样它和客户端一样，也得到了 A、B 和 C，继而到 X，以及最终的会话密钥。

* 于是，客户端和服务端都得到了能够加密解密传输数据的对称密钥——会话密钥。

## pull/push模型--解决HTTPS交互局限的问题

* 场景：一款网页版即时聊天工具，由于http本身的限制，服务端无法主动推送消息，影响到消息即时送达。
* 解决方式：
  * method1：定时轮询Poll。查询仍然不够及时（轮询间隔为可能的最大延时）；大量带宽和服务器资源浪费（每10s一次请求，1h就会有360次请求，但实际有用的消息只有1次）。
  * method2: pull/push模型。
    * **push>pull**: 1）**效率高**，每一次推送都是有意义的消息；2）实时性，每次推送都是实际发生后第一时间出发。
    * pull>push: **服务端不需要维护客户端列表、查询策略等，成为无状态简单服务。最终结果幂等性扩展（每次请求的结果一致）。**
* 服务端推送技术：
  * comet：web应用客户端和服务端交互的模型。
    * 大致原理：客户端发送一个普通的http请求到服务端后，服务端不像以往一样在处理后直接返回数据，而是保持连接不释放，每当有更新事件发生就使用分块传输的方式返回数据。
    * 100%由http协议实现。
    * comet方式下，服务端实质是对客户端的请求有条件、讲时机的多次返回。（假push）。
  * websocket：HTML5规范了websocket协议，通过HTTP/HTTPS 的端口来完成，最大程度上对 HTTP 协议通透的防火墙保持友好。
    * **双向、全双工协议。客户端和服务端都可以<u>主动</u>发起请求，回复响应，且两边的传输都互相独立。**
    * 二进制协议，头部开销较小，传输效率更高；客户端和服务端双方约定一些协议，不必在传输过程中带来带去。
    * 相比于 HTTP，没有同源的限制，服务端的地址可以完全和源页面地址无关，不会出现“跨域问题”。

# SOAP & REST

## SOAP-Simple Object Access Protocol

* 定义了数据对象传输的格式，以便在网络的节点之间交换信息。（与http相似，都在 OSI 7 层模型的应用层上，但互不冲突，SOAP 并不依赖于 HTTP 而存在，而且它们可以互相配合。）
* HTTP 负责信息的传输：关心消息的送达，但却不关心这个数据代表着什么。
* SOAP负责信息的内容：关心怎样把这个数据给序列化成 XML 格式的文本，在传输到对端以后，再还原回来。

**Notes: 消息传输就像快递，HTTP 主要关心的是信封，而 SOAP 主要关心的是信封里的物件。**

* **soap是具体的协议。**

## REST-Representational State Transfer

即表现层状态转换，指的是一种为了信息能在互联网上顺利传递而设计的软件架构风格。

* **REST 是风格，而非协议或标准**：至于 HTTP，它是 REST 风格的重要载体。重要，但不是唯一，因为载体并不只有 HTTP 一个，还有 HTML 和 XML，它们恰当地互相配合，组合在一起，来贯彻和体现 REST 的风格。
* 大多数情况下，REST更适合当前的互联网环境。

# 数据持久化

## 缓存

* 本质：节约对原始资源的重复获取开销，将结果数据副本存储以供获取的方式。
  * **空间换时间**：在业务中会被重复获取的数据才有必要设计为缓存，**“缓存命中率--判断该资源是否需要继续缓存的指标”**
  * **减少资源开销和占用**：时间开销、CPU、网络、I/O开销等。
* 缓存主要针对“资源”：如果一个操作是”幂等”、“安全”的，那么这个操作可以被抽象为资源进而被缓存。

### 缓存应用模式

* **Cache-Aside**：
  * 客户端发请求，应用先查看缓存是否有目标数据。
  * 如有则直接将缓存返回给请求方。
  * 如果没有执行正常查询，查询得到的数据返给客户端的同时在缓存处缓存一份。
  * 数据更新，**先更新应用**，应用中**再令缓存中的数据失效**。【顺序必须固定，否则会导致数据不一致的问题出现。】
    * 更新应用后**“令缓存失效而不是更新缓存为数据库最新值的原因”**：直接更新可能存在多个更新导致缓存中的数据为最后一次更新的情况，而不是最终期望的更新结果。
* **Read-Through**：
  * 缓存变为数据库代理，应用请求只能看到缓存的返回数据，数据库对应用是透明的，应用不直接访问数据库。
  * 应用向缓存要求数据，若有则缓存直接返回数据；若没有则由缓存查询数据库，得到数据后先写入缓存，同时返回给应用。
* **Write-Through**：【**缓存内部系统需要自己保证并发场景下，缓存更新顺序和数据库更新顺序一致**。】
  * 类似于Read-Through,用来处理数据更新的场景。
  * 如果待更新目标数据缓存中有，则先更新缓存中的数据。
  * 缓存更新完毕之后再更新数据库中的数据。
  * 数据库中更新完毕后由缓存告知应用。
* **Write-Back**：
  * 更新操作发生时，数据写入缓存后就立即返回了；数据库的更新则是异步完成（常见于各类分布式系统）。
  * 优点：吞吐量高、操作迅速、数据库可批量进行更新。
  * 缺点：异步可能会明显带来数据不一致、数据丢失的问题。

### 缓存使用的问题

* 缓存穿透：在某些情况下，大量对于同一个数据的访问，经过了缓存屏障直接访问数据库，造成数据库连接资源占用激增等情况，甚至造成数据库异常。
  * 解决方法：1）缓存中预先缓存“key不存在orkey对应的value不存在”； 2）“布隆过滤器算法”：在数据库查询前预先过滤调某些不存在的结果。
* 缓存雪崩：原本对于引应用起屏蔽作用的缓存，如果在一定时间段内，对大量请求访问失效，造成欲保护应用系统压力过大，过载、宕机等问题。
  * 解决方法：缓存预热（主动加载一定量的热点数据到缓存）、限流（限制缓存没有时候发送到数据库的请求数量）、避免大量缓存同时写入（同时过期时如果发生请求也可能存在缓存雪崩对系统造成压力。）
* LRU(Least Recently Used): 维护一个限定最大容量的队列，队列头部总是放置最近一次访问的元素，队尾放置访问量最少的元素，访问量超过队列长度时将队尾元素出队。【缓存数量维护】
  * LRU用于缓存访问存在的问题：**如果用户有意无意的访问一些错误信息，在缓存中就会破坏掉LRU队列最近最常访问的缓存数据真实性。**
  * 优化方案**<u>LRU-K</u>：** 主缓存队列排的是访问次数大于K的元素，访问次数小于K的队列放在另一个队列中。（这样可以解决上面提到的少量访问导致一个队列中的LRU元素信息失真的问题。）


------

