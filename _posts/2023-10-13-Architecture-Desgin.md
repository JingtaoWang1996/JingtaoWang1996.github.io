---
title: 'Architecture-desgin-notes'
date: 2023-10-13
permalink: /posts/2023/10/architecture-Design-notes/
tags:
  - cool posts
  - category1
  - category2
---

System architecture notes lists.



# 架构-解决系统复杂度问题

* **架构设计的关键：判断和取舍【各种约束条件下，求得最优解并运用】**
* **程序设计的关键：逻辑和实现**
* 模块&组件：系统的组成部分，从不同角度拆分系统。
  * 模块：逻辑角度拆分为各个功能模块，如登录功能、验证功能等。【功能分离】
  * 组件：物理角度拆分为各个组件，如nginx、kafka等。【单元复用】

* 框架framework：组件规范or开发规范。
* 架构architecture：系统基础结构。
  * **软件架构：软件系统的<u>顶层</u>结构。**
* **<u>架构设计的目的：解决软件系统复杂度带来的问题。</u>**
  * 针对系统复杂点进行架构设计。
  * 架构设计并不需要面面俱到，有针对性的根据问题进行设计解决。
  * 对比自己业务复杂点，选择参考相似的方案。

**简单案例-大学学生管理系统**

* 需求：登录、注册、成绩管理、课程管理等。
* 性能分析：一个大学：1-2w人，平均每天每个学生访问次数约为1次左右, 性能不算分复杂。
  * 存储：mysql。
  * 缓存：暂不考虑。
  * web服务器：nginx代理转发。

* 可扩展性：学生管理系统功能稳定，扩展空间不大&扩展性不复杂。
* 高可用性：宕机 几小时，对学生管理工作影响不大，可以不做负载均衡，不考虑异地多活等复杂方案。
  * 若学生数据全部丢失，只能人工逐条修复，**需考虑存储高可靠**。**【复杂点-架构重点解决：数据库备份、机房备份】**
* 安全性：信息隐私【nginx提供ACL控制、用户账号密码管理、数据库访问权限控制】
* 成本：系统很简单，几台服务器就能够搞定，无需太多关注。

# 复杂度来源1-高性能

高性能复杂度来源：

* **单台计算机内部为了高性能带来的复杂度**
* **多台计算机集群为了高性能带来的复杂度**

## 单机复杂度

* 单机复杂度最关键点：操作系统。【操作系统发挥硬件性能，操作系统复杂度直接决定软件系统复杂度。】
* 操作系统和性能最相关点：**进程**和**线程**。
  * 进程：每个进程对应一个任务。每个任务有独立的内存空间，进程间互不相关，操作系统统一调度。
    * 多进程：CPU分时调度，已达到模拟多进程并行的作用。
    * 进程间通信：管道、消息队列、信号量、共享存储等。
  * 线程：解决单进程内部只能串行，不支持并行的问题，提高性能。
    * 线程：进程内部的子任务，进程中所有子任务共享进程的数据和资源。
    * 互斥锁：多线程中保证数据正确性-同一时间进程中只能有一个线程获得修改某数据的权限，A线程释放后，B线程才能继续申请修改。
    * **操作系统最小调度单位：线程**
    * **操作系统最小分配资源单位：进程**
  * 多进程&多线程：本质是分时系统，并不能做到时间上真正的并行。
* 真正并行：多个CPU同时执行计算任务。【3种常用架构】
  * SMP（Symmetric Multi-Processor，对称多处理器结构）
  * NUMA（Non-Uniform Memory Access，非一致存储访问结构）
  * MPP（Massive Parallel Processing，海量并行处理结构）

## 集群复杂度

集群并非单纯单机数量增加，需要考虑集群之间如何配合，从而达到高性能的目的。常见集群分配方式如下：

**任务分配**

* 每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。

* 从1台增加到2台的过程，需要【按照逻辑进行任务分配、负载均衡】。
  
  <img src='/images/img/单机到2台扩展.png'>
  
  * 增加1台任务分配器【硬件网络设备（F5、交换机等）or 软件网络设备（LVS）or负载均衡软件（Nginx、HAProxy）or 自己开发的系统。
  * **任务分配器与真正业务服务器连接和交互**（即图中任务分配器到业务服务器的连接线），需要选择合适的连接方式，并且对连接进行管理。【连接建立、连接检测、连接中断后如何处理等。】
  * 任务分配器的**分配算法**。【轮询，权重分配，按负载分配】

* 上述假设扩展到2台后，理论上性能翻倍，但实际由于各种限制，可能需要打8折计算。
* 若性能要求继续提高，**增加服务器的同时还需增加任务分配器**。
  * 多台任务分配器之间需要明确的分配方式。
  * 任务分配器和服务器之间变成多对多的形式。
  * 多服务器的维护、状态管理、故障处理难度加大。

**任务分解**

* 通过任务分配，能突破单机处理性能的瓶颈，增加更多的机器来满足业务的性能需求。

* 若业务本身复杂度增高，单纯通过任务分配扩展性能的效果会越来越差。
* **分解粒度不能过细，否则调用次数激增导致性能更差。**

<img src='/images/img/任务分解.png'>

以微信架构为例，通过接入服务器后，在后台对各个子业务进行拆分，将复杂且巨大的业务拆分成多个小而简单的子系统，从以下方面提升性能：

* **系统越简单，越容易做到高性能**：简单系统影响性能的点更少，更容易有针对性的优化。
* **可以针对单个任务进行扩展**：各逻辑任务分解到独子系统后，整个系统性能瓶颈更容易发现，且发现后只需针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多。

# 复杂度来源2-高可用

**高可用的实现本质：冗余**【多台备用，增加冗余单元】

## 计算高可用

* **无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的**。所以将计算从一台机器迁移到另外一台机器，对业务没有影响。
* m台冗余计算单元的情况下，通过任务分配器后，可以分为：n主m-n备【结合实际业务判断】
* m台冗余计算单元的情况下，复杂度提高。

## 存储高可用

对需要存储数据的系统，整个系统高可用设计关键点和难点在于“存储高可用”。

**存储高可用的难点：不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响**。

* 与计算相比，存储有一个本质区别：**将数据从一台机器搬到到另一台机器，需要经过线路进行传输**。
  * 不同线路、不同距离的传输速度不同。
  * **ms级延迟对人影响不大，但对高可用系统，在某个时间节点上，数据会存在不一致的情况。**【银行业务数据不同步，用户体验低甚至产生大问题】

* 传输线路本身也存在可用性问题：传输线路中断、拥塞、异常（错包、丢包）
* 传输线路故障时间一般都特别长，十几分钟到几个小时都有可能。【2015 年支付宝因为光缆被挖断，业务影响超过 4 个小时；2016 年中美海底光缆中断 3 小时】

* 存储高可用最多同时满足“一致性、可用性、分区容错性”中的两个，在做架构设计时需结合业务进行取舍。

## 高可用状态决策

* 计算&存储高可用基础都是“**状态决策**”：系统判断当前状态是否正常，若异常就采取行动来保证高可用。
* 若状态决策本身有错误或偏差，后续行动和处理无论多么完美也都没有意义和价值。
* 具体实践中，恰好存在一个本质的矛盾：**冗余实现的高可用系统，状态决策本质上就不可能完全正确**。
  * 独裁式：系统存在唯一决策者进行“状态决策”，不会出现决策混乱，但决策者本身故障时问题出现。
  * 协商式：两个独立的个体通过交流信息，然后根据规则进行决策，**最常用的协商式决策就是主备决策**。【关键点：两者信息交换出现问题-主备切换、增加连接等】
  * 民主式：多个独立个体间信息交换后进行投票决策，按照**多数取胜**的规则确定最终状态。【zk选举leader的方式】。
    * 民主式决策算法复杂：ZK 的选举算法 Paxos
    * 各节点连接切断后, 相互之间无法交互信息，导致可能选举出多个leader。【解决方案：投票结果超过一半为准，可能会因为可投票数量不足而导致永远无法完成选举】

# 复杂度来源3-可扩展性

良好的可扩展系统的两个基本条件：正确预测变化、完美封装变化。

## 预测变化

* 软件发布后还可以不断地修改：**不断有新的需求需要实现**。
* 预测变化的复杂性在于：
  - 不能每个设计点都考虑可扩展性。
  - 不能完全不考虑可扩展性。
  - 所有的预测都存在出错的可能性。

## 应对变化

即使预测很准确，如果方案不合适，则系统扩展一样很麻烦。常见的应对办法有如下几种：

* **将可能的"变化"封装在变化层，稳定不变的单独为一个”稳定层“**
  * 问题1：系统需要拆分出明确的变化层和稳定层。
  * 问题2：需要设计变化层与稳定层之间的接口。

* **提炼“abstract抽象层”和“实现层“：抽象层稳定、实现层根据业务需要变化。**

# 复杂度来源4-低成本、安全、规模

## 低成本

* 当架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标。**如果架构方案涉及几百上千甚至上万台服务器，成本就会变成一个非常重要的架构设计考虑点。**【eg: 两个架构设计方案：A 方案需要 10000 台机器，B 方案只需要 8000 台机器，从数量来看，B 方案节省 2000 台机器，1 台机器成本预算每年大约 2 万元，一年下来节省 4000 万元。】
* 低成本：架构设计的约束条件，非首要目标。【根据高性能、高可用的要求设计出方案时，评估方案是否满足成本目标，如果不行，就需要重新设计架构；如果无论如何都无法设计出满足成本要求的方案，那就只能找老板调整成本目标了。】

**低成本复杂度来源**：引入新技术or创造新技术来解决成本架构问题。常见例子如下：

- NoSQL（Memcache、Redis 等）：为了解决关系型数据库无法应对高并发访问带来的访问压力。
- 全文搜索引擎（Sphinx、Elasticsearch、Solr）：为了解决关系型数据库 like 搜索的低效的问题。
- Hadoop ：为了解决传统文件系统无法应对海量数据存储和计算的问题。

- **Facebook**： 为解决 PHP 低效问题，从 使用HipHop PHP【将 PHP 翻译为 C++ 执行】，改为 HHVM【PHP翻译为字节码后由虚拟机执行，类似与Java和JVM】。
- **新浪微博**：将Redis/MC + MySQL 方式，扩展为 Redis/MC+SSD Cache+MySQL 方式。SSD Cache 作为 L2 缓存使用。【解决MC/Redis 成本过高，容量小的问题 & 穿透 DB 带来的数据库访问压力】
- **Linkedin** ：为了处理每天 5 千亿的事件，开发了高效的 Kafka 消息系统。【**kafka设计出现原因**】

相比来说，创造新技术复杂度更高，因此一般中小公司基本都是靠引入新技术来达到低成本的目标；而大公司更有可能自己去创造新的技术来达到低成本的目标，因为大公司才有足够的资源、技术和时间去创造新技术。

## 安全

**功能安全**

* 防止攻击者对于系统漏洞的利用。
* 多与代码实现相关，与架构关系不大。【很多开发框架内嵌常见的安全功能，减少安全相关功能重复开发】
* 框架内嵌的安全功能无法预知新问题，且框架本身也存在很多漏洞。【Apache Struts2 多次爆出调用远程代码执行的高危漏洞】
* 功能安全是一个逐步完善的过程，且往往都在问题出现后才能有针对性的提出解决方案，我们永远无法预测系统下一个漏洞在哪里，也不敢说自己的系统肯定没有任何问题。

**架构安全**

* 功能安全是“防小偷”，那么**架构安全就是“防强盗”**。强盗会直接用大锤将门砸开，且很多时候就是故意搞破坏，对系统的影响也大得多。【理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。】
* **传统架构安全主要依靠防火墙**：最基本的功能就是隔离网络，将网络划分成不同的区域，制定出不同区域之间的**访问控制策略**来控制不同信任程度区域间传送的数据流。
  * 防火墙功能强大、性能一般，多用于传统银行&企业领域应用。
  * 对于海量用户访问的高并发情况，防火墙性能无法支撑。【DDoS：几GB-几十GB； 即使部署防火墙，多台的成本极高】
  * **防火墙能够保证内部系统不受冲击，但<u>DDoS最大的影响是消耗机房出口总带宽</u>，当出口带宽耗尽，整个业务从用户端就是不可用的**

基于上述原因，架构安全没有太好的设计手段来实现，更多**依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现**。

## 规模

**规模带来复杂度的主要原因：“量变引起质变”**【数量超过一定的阈值后，复杂度会发生质的变化。】常见的规模带来的复杂度有：

* 功能越多，系统复杂度指数级上升：**系统的复杂度 = 功能数量 + 功能之间的连接数量。**

- 数据越多，系统复杂度发生质变：大数据。【目前的大数据理论基础是 Google 发表的三篇大数据相关论文】

  * Google File System：大数据文件存储的技术理论
  * Google Bigtable ：列式数据存储的技术理论
  * Google MapReduce：大数据运算的技术理论

  Mysql 单表数据一般推荐在 5000 万行左右，若单表数据达到了 10 亿行，就会产生很多问题，例如：

  * 添加索引会很慢，可能需要几个小时，这几个小时内数据库表是无法插入数据的，相当于业务停机了。
  * 修改表结构和添加索引存在类似的问题，耗时可能会很长。
  * 即使有索引，索引的性能也可能会很低，因为数据量太大。
  * 数据库备份耗时很长。

# 架构设计&流程

## 设计原则

* **“合适＞业界领先”**：技术的选择优先确保适合当前业务&人员。
* “简单＞复杂”：减少系统组件间故障 & 减少某个变化出现后对其他组件的影响 & 定位排查更简单。
* “演化>一步到位”：软件系统永远存在逐渐变化的过程，一步到位的情况基本不可能发生。

## 设计流程

* step1识别复杂度：大部分场景，复杂度只是其中的某一个，少数情况下包含其中两个，如果真的出现同时需要解决三个或者三个以上的复杂度，说明这个系统之前设计有问题OR架构师的判断出现了失误。实际执行过程必须进行**【优先级排序】**。
* step2
* 

****
















































------

