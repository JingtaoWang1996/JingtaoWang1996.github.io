---
title: 'Network-Protocol‘
date: 2023-12-12
permalink: /posts/2023/12/Network-protocol/
tags:
  - Theoretical Ground
---

Network protocol note conclusion.

# 网络协议综述

* 协议三要素：语法（内容符合一定的规则和格式）、语义（内容有一定意义）、语序（执行的先后顺序）。

## 具体示例

**以电商购物为例**---常用的网络协议

* 应用层：DNS(找到访问ip地址)、http\https(传输访问内容：查询的信息or买多少等)
  * next：经过应用层封装后的内容交给下一层（传输层），通过socket编程实现。
* 传输层：UDP【无连接协议-只管发出1次，不管是否能够到达】，TCP【面向连接的协议-确保所发出的数据包能够到达，无法到达就重新发送】
  * TCP 协议一般监听两个端口：浏览器监听端口、电商服务监听端口。【通过端口判断收到的包下一步发送到哪个进程进行处理。】
  * next：传输层封装完毕后，浏览器将数据包交给操作系统的网络层。
* 网络层：IP协议。通过源ip和目的ip确定数据包的传输路径，进行数据传输。
  * 首先将ip地址发给网关：**通过ARP协议，确认gateway的MAC地址**
* MAC层：确定网关MAC后，将IP包交给MAC层，网卡再将包发出去。【因为包中包含MAC地址，因此能够到达网关】
  * 网关的实质-路由器：通过本身存储的路由表，判断这个包下一步应该发送到哪一个路由器，最终到达目的ip的网关，然后重复上述步骤解码提取得到传输的内容。
* 收包过程：通过路由表最终到达目标ip后，逐层解包得到传输内容。
  * TCP 层：对于收到的每个包，都会回复一个包收到的说明，沿着传输过来的路返回。【为了丢包重传的情况做准备，一定时间内没收到消息就重传-tcp的3次握手。】

**各层包封装示例如下**

| MAC头-MAC层       | 客户端电脑mac：xxxx，网关mac：xxxx                         |
| ----------------- | ---------------------------------------------------------- |
| IP头-网络层封装   | 客户端ip-源ip：192.168.1.101；电商服务器ip：106.114.138.24 |
| TCP头-传输层封装  | 浏览器端口：12345，电商应用端口：443                       |
| HTTP头-应用层封装 | POST,URL,HTTP 1.1，正文格式：json，正文长度：1234          |
| 内容              | 我要买xxx，买多少                                          |

## 网络分层

* 网络分层的原因：复杂的程序都要分层，每一层专注做本层的事情。
* 层与层之间的关系**：<u>只要在网络上跑的包，都是完整的，可以有下层没有上层，绝不可能有上层没有下层。（应用层可以没有，但只要想发送到网络上，ip层和MAC层一定有。）**</u>
* **二层设备**：<u>收进整个网络的包，各层协议都有。只去掉MAC头，看是丢弃、转发还是保留</u>。
* **三层设备**：<u>**MAC头去掉后，再把IP头摘掉**，确认是需要丢弃、转发，还是保留。</u>

## CIDR-无类型域间选路

解决前期前期积累IP分类不够用的情况：将**32位的IP地址一分为二-网络号+主机号**

* eg：10.100.122.2/24，这种表示形式即为CIDR。【24的意思，32位ip中，前24位是网络号，后8位是主机号】
* 伴随CIDR存在的两个地址：
  * **广播地址：** 10.100.122.255
  * **子网掩码：** 255.255.255.0
* 以10.100.122.2/24 为例，（子网掩码） AND （IP地址：10.100.122） = **网络号**（10.100.122.0）。

## 关于ip配置

假设旁边机器是192.168.1.x，自己的服务器如果配成 16.158.23.6，那么包是发不出去的。【因为没有MAC层】

* 自己的MAC地址容易直到，但目标的MAC地址，如果不在同一个网段，无法通过ARP请求获取MAC地址。
* 在不是一个网段的情况下，它不会直接将包发送到网络上，而是发送到网关。【如果配置了网关的话，linux会获取网关的MAC地址，然后发送；没有配置网关的情况下，数据包根本无法发送。-ping不通】

### DHCP 动态主机配置协议

* DHCP-Dynamic Host configuration protocol

* 网管配置共享的ip地址池，每台新接入的机器都通过DHCP来池里申请，然后自动配置，使用完成后，IP地址回到共享池即可。

**工作方式**

* **DHCP discover**：新加入的机器，只知道自己的MAC地址，没有ip，因此，需要使用0.0.0.0 发送一个广播包到255.255.255.255.【广播包中封装了UDP,UDP封装了BOOTP(增强后是DHCP)】
  * 广播包中的内容，通过BOOTP头，向局域网中广播请求租一个ip的信息。
* **DHCP offer**：配置了DHCP server的情况下，它通过MAC地址识别这个包是从一个新机器发出，并使用**广播地址作为目的地址**（因为新机器目前还没有ip地址可供使用）发出：拟提供的ip、子网掩码、网关、租期等信息。【此处感觉在局域网内可以直接使用MAC地址发到网卡】
* **DHCP request**：新机器收到一个或多个DHCP server给到的回复后，会选择一个DHCP offer（一般是最先到达的），并向网络中发送一个DHCP request广播数据包，包含：客户端MAC地址、接收租约中的ip、提供租约的DHCP服务器地址【告诉其他DHCP服务器，请求撤销之前提供的ip，以便提供给下一个ip地址租用者。】
  * 此时还没有得到DHCP server的最后确认，客户端仍然使用0.0.0.0作为源ip，255.255.255.255为目的ip广播。
* 当DHCP server接收到客户端机器的 DHCP request之后，会广播返回给客户端机器一个 DHCP ACK消息包【此处已有ip，感觉可以直接使用ip或像上面一样，使用MAC地址】，表明已接收客户机的选择，并将这一ip地址合法租用信息和其他信息都放入该广播包中，发给客户机，确认入网。【之后客户端机器可以使用该ip作为源ip，广播还有个目的-让局域网内所有人知晓该ip已被占用。】

**ip地址回收&续租**

* 客户机在租期过去50%的时候，直接向为其提供ip地址的DHCP Server 发送 DHCP request 消息包，接收到该服务器恢复的DHCP ACK 消息包后，根据包中所提供的新租期等信息更新 TCP/IP 参数，完成ip续租。

### PXE-预启动执行环境

数据中心中，管理员对于上百台机器，最希望的是：自动装好系统后，自动分配ip地址，然后直接启用。

**操作系统启动过程概述**

```
* 首先启动bios-一个特别小的系统，只能：读取硬盘的MBR启动扇区,启动GRUB，将权利移交给GRUB；
* GRUB启动后，加载内核、作为根文件系统的initramfs文件,将权利移交给内核；
* 内核启动，初始化整个操作系统。
```

PXE - 基于上述操作系统启动过程概述，安装操作系统只能在BIOS启动后，这个过程即为：预启动执行环境（Pre-boot Execution Environment）

**PXE 概述**

* 区分客户端&服务端，由于没有操作系统，只能将客户端放在bios里面。当计算机启动时，BIOS将PXE客户端调入内存，之后可以连接到服务端进行下一步操作。
* 首先PXE客户端自己也需要一个IP地址：PXE客户端启动后，就可以**发送DHCP请求**，获得被分配的ip地址。
* DHCP server 分配ip的同时，在配置中提前配好：**next-server**：指向PXE服务器地址；**filename**：初始启动文件。
  * 初始化文件的下载，通过TFTP协议，因此PXE服务器上，往往还需要一个**TFTP服务器。**
* 完成上述步骤后，确保PXE在启动后，发送DHCP请求之外，除了能得到一个ip，还能得到PXE服务器的位置，及初始启动文件路径，用于初始化操作系统。

## ARP协议

* 已知IP地址，求MAC地址的协议。

* 机器本地也会缓存一个ARP表，并定时更新，减少对ARP过于频繁的请求。

# 各层

## 1st-物理层

* 物理层设备：Hub集线器（完全工作在物理层，采取广播模式）

## 2nd-MAC链路层

以hub为例，广播模式需解决：包发给谁？谁该接收？多个机器同时发送有无发送规则？发送错误解决方式？

【上述问题均在MAC层解决】

**MAC**：Medium Access Control 媒体访问控制

* **控制向mac层发送数据的先后问题，防止混乱。**【多路访问】
  * 信道划分：分多个通道，每个通道传输自己的内容。
  * 轮流协议：同一个通道，轮流传输。
  * 随机接入协议：有消息就发送，如果发现链路上很堵，就执行指数退让，直到链路上较为正常时再发送。
* **发给谁&谁接收的问题：MAC地址进行处理操作。**

**二层网络包格式**：**目的MAC地址|源MAC地址|类型|数据|CRC**

* 目的MAC地址：放最外一层，便于确定数据是发给谁的。网卡MAC地址=目的MAC地址的情况下，把包收进来，
* 类型：0800-IP数据报；0806-ARP请求，应答。【收进来后打开IP包&TCP包，确认ip地址和端口后，继续向上将数据传入应用层进行解析。】
* CRC-循环冗余检测：通过XOR异或，计算整个包传输过程是否发生错误。

**二层设备**：

* **交换机**：将数据包MAC头取出，检查目标MAC地址后，根据策略转发的设备。

  * 当一台电脑MAC1将一个包发给MAC2时，数据包经过交换机时，<u>**交换机将明确的MAC1来自哪台电脑记住。**</u>
  * 重复上述步骤到一定时间后，交换机自己维护的转发表，就能够知道来的包下一步应该转发到哪里。【交换机自学习】

  当交换机数量上升到一定程度后，可能会出现：**环路问题**。【Spanning Tree Protocol-解决环路问题】

  * 将图中的环破坏后，就生成了树，通过STP-Spanning Tree Protocol 进行。

* **STP**

  * Root Bridge-根交换机：树型结构交换机的根节点。
  * Designated Bridges-指定交换机：树型结构的子节点，非叶节点，叶节点多为“主机”
  * Bridge Protocol Data Units (BPDU)- 网桥协议数据单元：两个交换机之间互相发送BPDU, 比较出优先级后，一个作为父节点，另一个作为子节点。【重复上述过程直到所有交换机构成树型结构。若选举完成后，根节点交换机down了，需要重新选一遍。】
  * Priority Vector-优先级向量：[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID], 按照优先级顺序比较获得两个交换机的上述向量，获得优先级顺序。

**广播问题&安全问题**：机器多了，交换机肯定也会增多，即使交换机比Hub智能，但在一个局域网广播域当中，很多包会被不相关的机器通过抓包方式获取未加密内容。解决方法：

* 物理隔离：每个部门一个单独的交换机&单独的子网，但这样可能会产生浪费。
* 虚拟隔离：VLAN 虚拟局域网。**在原来的二层头上加一个TAG，里面有一个VLAN ID 共12位，2^12=4096个用户。**【只有相同的VLAN包，才会互相转发，不同VLAN包是看不到的，解决了广播和安全问题。】
  * 对于支持VLAN的交换机，通过**Trunck口**，转发属于任何VLAN的口。

**ICMP协议-Internet Control Message Protocol 互联网控制报文协议**

* Ping 是基于ICMP协议工作的。
* ICMP报文封装在IP包当中，因为传输指令必须要源ip和目的ip：IP头|ICMP报文
  * ICMP报文有很多类型，不同类型有不同代码：最常用的类型【主动请求-8，主动请求应答-0】
  * Ping 即为常用的主动查询报文请求，并且获得主动应答的ICMP协议。【在主动发出的ICMP之后加入自己的格式】
* ICMP Echo Request：对ping的主动请求进行网络抓包。
* ICMP Echo Reply：对于主动请求的回复，比起原生的ICMP，多了两个字段：标识符（探测什么的返回）& 序号（第几个请求）
* 差错报文：3-终点不可达（0-网络不可达；1-主机不可达；2-协议不可达；3-端口不可达）；4-源抑制（让源站放慢发包速度）；11-超时；5-重定向；

**ping：查询报文类型的使用**

假设同一个子网的两台主机AB互相ping，则：

* 源主机首先构建一个ICMP请求数据包，插入必须数据后，交给IP层;
* IP层将B作为目的IP，本机作为源IP，加上控制信息构成一个IP数据包。
* 通过已知orAPR协议查找目的节点的MAC地址，在ip数据包上加入MAC头，之后从链路层传出。
* B收到这个包后，先比较MAC地址；一致在检查ip地址，之后将有用信息提交给ICMP协议并做出应答。
* 在规定时间内没有收到ICMP应答包则说明：数据不可达，源主机获得延迟。

PS：如果网络不通且不在我们的控制范围 & 禁ping的情况，需要通过其他协议（如：telnet来确定网络是否通）

**traceroute: 差错报文的使用**

* <u>**故意使用错误的报文来确定路径和目标主机是否可到。**</u>

* 作用1：故意设置特殊的TTL，来追踪取完目的地时经过的路由器。【TTL设置成1，一旦遇到一个路由器，则返回一个ICMP包，统计经过哪个路由器；之后TTL设置为2，以此类推,直到到达目的地。】
* 作用2:  故意设置不分片，从而确定路径的MTU.

## 3rd-IP层

**三层设备**：将MAC头和IP头都取出后，根据里面的内容确定接下来包则发往哪里的转发设备。

* 网关往往是一个路由器，一个三层转发的设备。
* **路由器**：是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。【包含下一跳的规则】

**静态路由**：在路由器上配置一条一条的规则（eg：从哪儿进到哪儿出等等），按规则转发。

MAC地址是一个局域网内才有效的地址，因此，**MAC地址经过局域网必定改变**

* **转发网关**：不改变IP地址的网关。
* **NAT网关**：改变IP地址的网关。

**路由配置**

* Again：路由器-一台网络设备，有多张网卡，当一个入口的网络包传送到路由器时，它会根据一个本地信息转发库，来决定如何正确的转发流量。
* **路由表**：路由器中的本地信息转发库。一张路由表中会有多条路由规则，每条规则至少包含以下3条信息：
  * 目的网络：这个包想去哪儿。
  * 出口设备：将这个包从哪个口扔出去。
  * 下一跳网关：下一个路由器地址。
* 路由可通过route 或 ip route 命令进行查询或配置。
  * eg: ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0

   **路由策略配置**

* 可根据多个参数（源ip地址、入口设备、TOS等）选择路由表，然后在路由表中查找路由。
  * ip rule add from ip1 table 10   从ip1来使用table10的路由表。
  * 一条路由规则中，也可以走多条路径【家里有两根网线属于不同的运营商，此时就需要能够接两个外网的路由器。】
* 动态路由算法：**动态路由器可根据路由协议算法生成动态路由表，随网络变化而变化**。
  * 根据最短路径算法or链路状态路由算法，**构建全局路由表**并计算出从当前路由器到目标路由器的最短路径。
  * cons：每次都需要发送全局路由表，网络结构大的情况无法承受。
* 动态路由协议：
  * 基于链路状态路由算法的**OSPF(Open Shortest Path First)**：基于链路状态路由协议，广泛应用于数据中心内部，又被称为**“内部网关协议Interior Gateway Protocol”**
    * OSPF重点：找到最短路径，若有多个最短路径，则可进行负载均衡分摊流量。
  * 基于距离矢量的路由BGP
    * 外网的路由协议，需要考虑的因素除了距离，还有政策等问题。

## 4th-传输层

### UDP & TCP

**区别**

* TCP：面向连接，3次握手确定连接建立后再进行数据传输。
  * **建立连接：为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。**
  * TCP 提供可靠交互，确保数据无差错、不丢失、按顺序到达。
  * TCP面向字节流：以流的形式发送。
  * TCP拥有**拥塞控制**，网络环境较差会减慢发送速度。
* UDP：面向无连接，不需要建立连接后直接传输数据，如：dig；直接向目的地址发包等待返回判断超时。
  * UDP继承IP包的特性，不保证不丢失，不保证按顺序到达。
  * UDP基于数据报，一个一个发，一个一个收。
  * UDP只管发送，不管是否发送成功及接收顺序是否正常。

### UDP 

**使用场景**

* **需要资源少、网络较好的内网or对于丢包不敏感的应用**。

* **不需要一对一沟通建立连接，而是可以广播的应用。**
* **需要处理速度快、时延低、少数丢包可容忍的情况。**

### TCP 

A-发送端； B-接收端

* TCP默认网络不可靠，丢包、乱序、重传、拥塞都是常有的事情，需要从算法层面来保证可靠性。

* 重点关注：顺序保证、丢包重传、连接维护、拥塞控制。

* 三次握手除了双方建立连接外，还需要沟通TCP包的序号问题。【A-B:起始序号从哪个开始;B-A：B收到的发包是从哪个开始的】

* 四次挥手：

  正常情况---【**AB都互相知道对方已结束**】

  * A发完最后的数据，B还没有做完自己的事情，还会向A发送，因此B为半关闭状态。
  * 此时A可以选择不再接收数据，也可以选择再最后接收一段数据，等待B主动关闭。
  * B主动关闭后，整个连接全部关闭。

  异常情况

  * A向B发送结束后，A直接关闭。【此时B发起的结束，没有应答，B就无法关闭。】
  * A向B发送结束后，B直接关闭。【A未收到应答，不确定B是否还有数据要发送，会一直等待。】

**[TCP状态机](https://blog.csdn.net/zwl1584671413/article/details/110472714)**：通过状态机能够准确理解，TCP建立连接和断开连接的具体时序。

### SOCKET编程

* 在网络层，socket函数需要指定到底是IPV4-AF_INET & IPV6-AF_INET6。
* 同时还需要指定：TCP-SOCK_STREAM   UDP-SOCK_DGRAM。

#### 基于TCP的Socket调用过程

* 两端创建了Socket。

* TCP调用bind函数监听一个端口，给这个socket赋予一个IP地址和端口。【有了ip和地址才能将网卡的包进行监听和获取。】

* 服务端有了IP和端口号，就可以调用listen函数进行监听。有了listen状态，服务端就可以接收由客户端发起的连接了。

* 内核中，为每个Socket维护两个队列：

  * 服务端和客户端已建立连接的队列：此时三次握手已完毕，处于establish状态。
  * 服务端和客户端未完全建立连接的队列，三次握手未完成，处于syn_rcvd状态。

* 服务端调用accept函数，拿出一个已经完成的连接进行处理，如果已经完成的队列里没有，就一直等待。

* 服务端等待的过程中，客户端可以通过connect发起连接（参数中指明要连接的IP地址和端口号），开始3次握手。**此时内核会给客户端分配一个临时的端口用于监听**，一旦握手成功，**服务端的accept就会返回另一个Socket**。

  **<u>PS: 监听的socket和真正传数据的是2个socket</u>**

* 连接成功后，双方开始通过read和write函数读写数据，类似于向一个文件流中写东西。

#### 基于UDP的Socket调用过程

* 两端创建Socket
* 通过bind获取ip和端口号用于交互。【因为UDP无连接，所以不需要listen和connect】
* 无连接状态的UDP不需要对每对连接建立一组socket，只要有一个socket就能和多客户端通信。
* 因为没有连接状态，每次通信的时候，都调用**sendto和recvfrom**传入ip地址和端口即可开始通信。

## 5th-应用层

### http

* 统一资源定位符-url：eg：http://www.163.com
* 目前http协议大部分是：1.1 默认开启Keep-alive, 这样建立的TCP连接，可在请求中多次复用。

* http报文：主要分为3大部分-请求行、请求首部、请求正文实体。
* 访问方法：GET、POST、PUT、DELETE。
* 首部字段：key-value格式存储的字段。可以获得最重要的信息：Accept-Charset-客户端可接受的字符集；Content-Type-正文格式；缓存 ...

* HTTP请求的发送：基于TCP协议，通过Stream的二进制流的形式传给对方。在TCP层，会把二进制流文件变成一个报文发送给服务器。

**http2.0**

* 在1.1的基础上，对http的头进行压缩，将原来每次都要携带的大量key-value在两端建立索引表，对相同的头只发送索引表中的索引。

* 将1个TCP连接切分成多个流，每个流有自己的id，且流有优先级，只是虚拟通道。

### https

相比于http，进行了加密操作。

**对称加密**

* 为了确保密钥的安全性，只能通过线下进行密钥沟通。
* 仅支持1对1的场景，多用户情况无法支持。

**非对称加密**

* 公钥可以随意传输，私钥在网站进行保存。
* 服务端和客户端之间的发送方采用对方的公钥加密，接收方采用私钥进行解密。
* 问题：普通用户如何确认获得的公钥是正确的

**Digital Certificate**

* 解决公钥可信度的问题：证书中包含-公钥、证书所有者、证书颁发机构、证书有效期。
* **证书生成：向权威机构CA-certificate Authority发起证书生成请求。**
  * 权威机构通过**签名算法**，使用自己的私钥给网站公钥进行前面，认证可靠性。

```shell
# 创建私钥
openssl genrsa -out cliu8siteprivate.key 1024
# 根据私钥创建公钥
openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem
# 生成证书请求
openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req
# CA 给证书签名
openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem
# 查看证书内容
openssl x509 -in cliu8sitecertificate.pem -noout -text 
```

PS: **各大CA机构的公钥默认安装在操作系统当中。因此，尽量不要安装来路不明的操作系统。**

### 流媒体协议

视频数据的传输

**基本定义**

- **编码后二进制文件格式**：AVI、MPEG、RMVB、**MP4**、MOV、FLV、WebM、WMV、ASF、MKV。

- **ITU标准**：H.261、 H.262、H.263、**H.264**、H.265。

- **ISO标准**：MPEG-1、MPEG-2、MPEG-4、MPEG-7。

- 视频的实质：快速播放一串连续的图片，每张图片称为1帧，只要每帧的数据足够多，人眼就无法区分是单独的图片【人眼：每秒24帧】

  * 每张图片由像素组成，假设1024*768；每个像素由RGB组成，每个8位，共24位。
  * 每秒视频大小：30帧\*1024\*768\*24 = 566231040Bits = 70778880Bytes；1min-4G

- 视频编码：解决视频传输数据过大的问题。【使用尽量少的Bit数保存视频】

  视频中图片能够压缩的原因：

  * **空间冗余**：一张图片相邻像素往往是渐变的，不是突变的，没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。
  * **时间冗余**：一个视频中连续出现的图片也不是突变的，可根据已有图片预测和推断。
  * **视觉冗余**：视觉对某些细节不敏感，不会每个细节都注意到，允许丢失一些数据。
  * **编码冗余**：不同像素值出现的概率不同，**概率高的用的字节少，概率低的用的字节多**。

  **视频编码两大流派**

  * International Telecommunications Union的**VCEG(video Coding Experts Group)**: 国际电连下的VCEG，主要侧重传输。
  * International Standards Organization的 **MPEG(Moving Picture Experts Group)**，主业做视频存储，后续逐渐关注视频传输。

  * 后来两者联合制定H.264/MPEG-4 AVC，作为最重要标准。

经过视频编码后，图像变成了一串二进制数据，按一定格式保存起来。【所支持主流格式均已列在上方。】

**直播方式**

* 网络协议将编码后的二进制视频流，从主播端推送到服务器端。
* 接流：服务器上有一个运行了同样协议的服务端来接收这些网络包，获取其中的视频流。
* 服务端接到视频流后对这些数据进行处理，如：转码。确保观众使用的客户端不同都能看到直播。
* 拉流：观众的客户端来请求这些视频流。通过视频分发网络，将视频预加载到就近的边缘节点（eg：ontent Delivery Network）降低服务器压力。
* 视频流拉取完成后，需要对视频进行解码，再转成帧在客户端播放出来。

**视频序列的三种帧**

* **I 帧：**关键帧，里面是完整图片，只需要本帧的数据就能完成解码。
* **P帧**：前向预测编码帧。P帧表示这一帧和前一个关键帧P帧的差别，解码时需要用之前缓存的画面，叠加和本帧定义的差别，生成最终画面。
* **B帧**：双向预测内插编码帧，记录本帧与后帧的差别，解码B帧需要之前和之后的画面，前后叠加取得最终的画面。
* I帧完整，B帧压缩率最高。

**二进制流-带结构**：网络提取单元NALU （Network Abstraction Layer Unit）

* Nalu头中主要是:NAL Type
  * 0x07：SPS,序列参数集，包含一个图像序列的所有信息，如图像尺寸、视频格式等。
  * 0x08：PPS,图像参数集，包含一个图像的所有分片信息，图像类型，序列号等等。

在传输视频流之前，必须传输这两类参数用于解码。【每个I帧前面都会传一遍这两个集合，保证容错性问题。】

**整个流程：** 一个视频，拆分成一系列帧，每个帧拆分成一系列片，每个片都放在一个NALU里，每个NALU之间通过特殊的起始标识符分隔，在每个I帧的第一片前面插入单独保存SPS和PPS的NALU，最终形成一个长长的NALU序列。





****