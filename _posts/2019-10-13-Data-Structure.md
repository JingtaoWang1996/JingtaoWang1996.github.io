---
title: 'Data-Structure-notes'
date: 2019-10-13
permalink: /posts/2019/10/Data-Structure-notes/
tags:
  - cool posts
  - category1
  - category2
---

Some data structure related notes.



# Basic take-ways

* 数据结构为算法服务 & 算法要作用在特定的数据结构上。
* 最重要概念-复杂度分析。

# 复杂度分析

不用具体的测试数据来测试，粗略估计执行效率的方法。

* 越高阶复杂度的算法，执行效率越低，
* 从低到高阶：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)

时间复杂度

**大O复杂度表示法：T(n)=O(f(n))** --- 代码执行时间与代码中表达式成正比

* **大O**-时间复杂度:不具体表示代码真正执行时间，而是**代码执行时间随数据规模增长的变化趋势**，所以又叫**”渐进时间复杂度“**。
* **<u>n表示数据规模的大小</u>**：为了表示增长趋势，当n极大时，**常量、系数、低阶**三部分均忽略不计。

空间复杂度

* 全称：**渐进空间复杂度（asymptotic space complexity**）。
* 表示**<u>算法的存储空间与数据规模之间的增长关系。</u>**

## 时间复杂度分析

常见分析方法：

* **只关注循环执行次数最多的一段代码**：这段代码执行次数的n的量级，就是整段代码的复杂度。
  * 只包含一个执行n次的循环，则：O(n)
  * 一个执行n次的循环当中还包含一个执行n次的循环，则：O(n^2)
* **加法法则：总复杂度等于量级最大的那段代码的复杂度**
  * O(n)  和 O(n^2) 的总复杂度为O(n^2)
* **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度乘积**
  * 循环内外复杂度乘积

几种常见时间复杂度分析

| 最高系数         | 复杂度   |
| ---------------- | -------- |
| 常量阶[非多项式] | O(1)     |
| 对数阶           | O(logn)  |
| 线性阶           | O(n）    |
| 线性对数阶       | O(nlogn) |
| 指数阶           | O(2^n)   |
| 阶乘阶[非多项式] | O(n!)    |
| 次方阶           | O(n^k)   |

* 常量阶：代码执行时间不随数据规模增大而增大，时间复杂度为O(1)【无：循环、递归】

* 对数阶、线性对数阶：

  * 例子：i从1开始，每循环一次就*2，直到大于n---O(x=log2n)【2的n次方后大于】

    ```python
    i = 1
    while i<n:
       i = i*2
    ```

    PS: 不管以多少为底数，类似上述例子的时间复杂度都为：**O(logn)**

* O(m+n)  &  O(m*n): 代码复杂度由两个数据规模来决定

  * O(m+n)：代码块中包含两个并列的循环块，且**无法评价两个循环的数据量哪个大的情况下**，两个部分都不能省略，因此时间复杂度为O(m+n)
  * 乘法法则仍然有效。

### 最好、最坏情况时间复杂度

* Best case time complexity：最理想情况下执行这段代码的时间复杂度。
  * eg：在list中遍历查找变量，找到后退出；最好的情况，第一个就是要查找的，时间为O(1)
* Worst case time complexity：最坏情况下执行这段代码的时间复杂度。
  * eg：在list中遍历查找变量，找到后退出；最坏的情况，最后一个才是要查找的，时间为O(n)

### 平均情况时间复杂度

* Average case time complexity：

  * eg: 【在list中遍历查找变量，找到后退出--一共n+1中情况=n个位置+不存在】

    将每种情况下需要遍历的元素个数累加然后除以所有的可能，就得到需要遍历的元素平均值。
    $$
    ((1+n)*n/2+n)÷(n+1)=n(n+3)/2(n+1)
    $$
    去掉常数、系数、低阶后：O(n)；这种计算方式存在的问题是：n+1种情况出现的概率不同。

* 一般情况下考虑最好最坏的极端情况即可，计算平均时间复杂度需要考虑不同情况的出现概率。

### 均摊时间复杂度

* 使用情况更加特殊：操作之间存在前后连贯的时序关系时，可以将这一组操作放在一起，看是否能将较高时间复杂度的操作耗时平摊到其他操作上。

* 一种特殊的平均情况时间复杂度。


## 空间复杂度分析

* 常见的空间复杂度： O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 对数阶复杂度平时都用不到。
* 空间复杂度计算：申请一个list，根据代码（eg：循环中不断向list存入数据）数据量扩大可能导致的不同量级的空间复杂度。

# 数组Array

* 定义：**线性表**数据结构，用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。

  * 线性表：数据排列成像一条线一样的结构，每个线性表上最多只有前后两个方向。【数组、链表、队列、栈也是线性表结构】
  * 非线性表：数组不是简单的前后关系【二叉树、堆、图等】
  * **连续的内存空间&相同类型的数据**：有这两个条件能确保随机访问。但同时导致若想要在数组中删除、插入一个数据，需要做大量数据迁移【为保证数据连续性】

* 数组实现下标随机访问数组元素--连续内存空间&相同类型数据为前提

  * 每个数组元素对应的内存地址计算公式

    ​           a[i]_address = base_address + i * data_type_size

    PS: 已知基地址数组开头元素的内存地址，要求第几个元素，数据类型对应的data_type_size

* 数组和链表的区别

  * 数组适合查找，时间复杂度为O(logn)
  * 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)

## 低效的插入和删除 & 改进方法

插入（长度为n的数组，将元素插入到第k个位置）

* 有序的情况下：k-n的所有元素往后移动一位，时间复杂度：末尾O(1),开头O(n),平均O(n)
* 无序：为了避免数据大规模搬动，直接将原来第k位的元素放到最后，然后插入新的，O(1)。

删除（长度为n的数组，删除第k个位置元素）

* k-n的所有元素往前移动一位，时间复杂度：末尾O(1),开头O(n),平均O(n)
* **将多次删除操作集中到一起执行，可以减少数据搬动：记录所有需要执行的删除操作后，最终统一搬动数据。------JVM标记清除垃圾回收的核心思想**

## 数组访问越界的问题

* 下述述代码中，数组大小为3，但循环中访问了a[3], 在C语言中，只要不是受限制内存，所有内存都可自由访问，根据基地址计算公式，访问到另一个不属于数组的内存地址。这个地址正好是i的内存变量地址，因此a[3]=0 相当于i=0，导致代码无限循环

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0}; // 数组大小为3,a[0]-a[2]
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

PS: C中，数组越界没有明确规定编译器如何处理，可能导致逻辑错误&代码攻击等等。

PPS: Java 中本身就会做数据越界检查：**java.lang.ArrayIndexOutOfBoundsException**

## 容器能否完全替代数组

针对数组类型，很多语言都提供了容器类，以Java为例：ArrayList

ArrayList VS 数组

* ArrayList

  * 封装数组操作细节 
  * **支持动态扩容**【每次空间不够，都会自动扩容为1.5倍】。

  * 但无法定义存储基本类型，eg：int->Integer; long->Long【特别关注性能的情况，可以考虑数组】

* 数组--部分语言中数组需要预先指定大小。

  PS: **扩容涉及的内存申请&数据搬迁较多，最好在创建的之初就能够大致估计一个范围。**

* 为什么数组要从0开始编号而不是从1开始？








------

