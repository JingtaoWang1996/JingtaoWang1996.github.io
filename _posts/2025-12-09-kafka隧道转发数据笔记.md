---
title: 'kafa隧道转发笔记'
date: 2025-12-09
permalink: /posts/2025/12/kafka隧道转发数据笔记/
tags:
  - Real Work Practice
---

外网VPS服务器部署kafka并进行转发到内网的步骤记录



# 说明

* 此文档记录了外网VPS服务器部署kafka并进行转发到内网的步骤
* VPS和云服务器上的部署路径：/leo/data_prober/

# 安装配置kafka 

* sudo apt update
* sudo apt install -y openjdk-17-jdk
* java -version
* 将下载好的本地kafka安装包上传到/leo路径下：cd /leo/
* 在上传目录上执行解压：tar -xzf kafka_2.12-3.6.2.tgz
* cd /leo/kafka_2.12-3.6.2
* 修改server.properties, 找到listeners，添加localhost部分：
  * vim config/server.properties
  * **listeners=PLAINTEXT://localhost:9092**

## 安装配置supervisor

* sudo apt update 
* sudo apt install supervisor
* 安装完成后的默认配置文件：/etc/supervisor/supervisord.conf
* 将需要守护的配置文件传到cd /etc/supervisor/conf.d/下
  * kafka.conf
  * zookeeper.conf
* 创建supervisor配置中的日志路径
  * mkdir /leo/kafka/
* 读取新增的配置：sudo supervisorctl reread
* 应用新增的配置：sudo supervisorctl update
   * 此时会出现：xxx successfully add to group
* 查看kafka的状态：sudo supervisorctl status

# VPS免密登录配置

* 在发起端服务器A执行：ssh-keygen -t rsa -b 4096
  * 之后一路回车，密钥对会自行生成
* 发起端执行命令复制A的公钥到B：ssh-copy-id root@123.45.67.89
  * 执行后会要求输入以此密码
* 测试免密登录：发起端ssh root@ip 即可

# 内网服务器端口转发消费kafka步骤

* **基本架构：内网服务器--（可SSH）-->VPS-A--(可SSH)-->VPS-B(kafka)**
* 内网服务器执行：
  * ssh -J root@8.134.76.31 -L 9092:localhost:9092 root@47.236.28.227 -N -f
    * -J root@8.134.76.31:先跳到VPS-A
    * -L 9092:localhost:9092:内网服务器9092转发到VPS-B的localhost:9092
    * root@47.236.28.227:连接到VPS-B
    * -N：仅端口转发不执行远程命令
    * -f：后台运行
    **前提：VPS-B上监听的是127.0.0.1:9092【仅配置listener为PLAINTEXT://127.0.0.1:9092】**
* 验证9092端口是否被监听：ss -tuln | grep ':9092\b'
* 测试消费：/test/kafkaConsumer.py放到41上运行
## 隧道转发遇到的问题

### kafka没有问题，但是隧道假活

* 初步解决方式

```
* 查看相关PID ps aux | grep "ssh.*47.236.28.227"
* sudo kill PID
* 执行之前的命令进行重启
```

# 隧道保活方式

隧道保活+自动重启+假活校验的实现方式记录

## 具体步骤

* 创建脚本文件:ssh_tunnel_keepalive.sh

```shell
#!/bin/bash
# 配置项（根据实际修改）
TUNNEL_PORT="9092"       # 隧道端口
JUMP_HOST="root@8.134.76.31"       # 跳板机A
TARGET_HOST="root@47.236.28.227"     # 目标机B
SSH_CMD="ssh -J ${JUMP_HOST} -L ${TUNNEL_PORT}:localhost:${TUNNEL_PORT} ${TARGET_HOST} -N -f"
PID_FILE="/var/run/ssh_tunnel_${TUNNEL_PORT}.pid"  # 记录隧道PID的文件

# 1. 定义函数：检测隧道是否真活（端口连通性）
check_tunnel_alive() {
    # 尝试连接本地隧道端口，超时1秒，无输出
    if nc -z -w1 localhost ${TUNNEL_PORT}; then
        return 0  # 端口通，隧道存活
    else
        return 1  # 端口不通，假活/已断
    fi
}

# 2. 定义函数：停止旧隧道（若存在）
stop_old_tunnel() {
    if [ -f ${PID_FILE} ]; then
        OLD_PID=$(cat ${PID_FILE})
        # 检查PID是否属于该SSH隧道进程
        if ps -p ${OLD_PID} >/dev/null 2>&1 && grep -q "ssh -J" /proc/${OLD_PID}/cmdline 2>/dev/null; then
            kill -9 ${OLD_PID} >/dev/null 2>&1
        fi
        rm -f ${PID_FILE}
    fi
}

# 3. 定义函数：启动新隧道（带保活参数）
start_new_tunnel() {
    # 核心：添加SSH保活参数，防止隧道被断开
    # ServerAliveInterval 30：每30秒向服务器发保活包
    # ServerAliveCountMax 3：3次保活失败则断开重连
    SSH_CMD_WITH_KEEPALIVE="ssh -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -J ${JUMP_HOST} -L ${TUNNEL_PORT}:localhost:${TUNNEL_PORT} ${TARGET_HOST} -N -f"

    # 执行隧道命令并记录PID
    ${SSH_CMD_WITH_KEEPALIVE}
    NEW_PID=$(pgrep -f "${SSH_CMD}" | head -n1)  # 匹配隧道命令的PID
    if [ -n "${NEW_PID}" ]; then
        echo ${NEW_PID} > ${PID_FILE}
        echo "$(date +'%Y-%m-%d %H:%M:%S') - 隧道重启成功，PID: ${NEW_PID}"
    else
        echo "$(date +'%Y-%m-%d %H:%M:%S') - 隧道重启失败！"
    fi
}

# 4. 主逻辑：检测+重启
# 先检查进程是否存在
if [ -f ${PID_FILE} ]; then
    CURRENT_PID=$(cat ${PID_FILE})
    if ! ps -p ${CURRENT_PID} >/dev/null 2>&1; then
        echo "$(date +'%Y-%m-%d %H:%M:%S') - 隧道进程已消失，准备重启..."
        stop_old_tunnel
        start_new_tunnel
    else
        # 进程存在，检查端口是否真活（防止假活）
        if ! check_tunnel_alive; then
            echo "$(date +'%Y-%m-%d %H:%M:%S') - 隧道进程存在但端口不通（假活），准备重启..."
            stop_old_tunnel
            start_new_tunnel
        else
            echo "$(date +'%Y-%m-%d %H:%M:%S') - 隧道正常存活"
        fi
    fi
else
    # 无PID文件，直接启动隧道
    echo "$(date +'%Y-%m-%d %H:%M:%S') - 无隧道PID文件，首次启动隧道..."
    start_new_tunnel
fi
```

* 权限配置

```shell
# 运行权限
chmod +x /leo/dataCollectionProber//ssh_tunnel_keepalive.sh
# 启动脚本
/xxxx/ssh_tunnel_keepalive.sh
```

* 配置定时任务

```shell
crontab -e
*/5 * * * * /leo/dataCollectionProber/ssh_tunnel_keepalive.sh >> /leo/ssh_tunnel_keepalive.log 2>&1
```












------

