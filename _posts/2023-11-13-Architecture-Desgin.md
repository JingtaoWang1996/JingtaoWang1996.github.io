---
title: 'CS-related-notes'
date: 2023-11-13
permalink: /posts/2023/11/architecture-Design-notes/
tags:
  - cool posts
  - category1
  - category2
---

System architecture notes lists.

# 架构-解决系统复杂度问题

* **架构设计的关键：判断和取舍【各种约束条件下，求得最优解并运用】**
* **程序设计的关键：逻辑和实现**
* 模块&组件：系统的组成部分，从不同角度拆分系统。
  * 模块：逻辑角度拆分为各个功能模块，如登录功能、验证功能等。【功能分离】
  * 组件：物理角度拆分为各个组件，如nginx、kafka等。【单元复用】

* 框架framework：组件规范or开发规范。
* 架构architecture：系统基础结构。
  * **软件架构：软件系统的<u>顶层</u>结构。**
* **<u>架构设计的目的：解决软件系统复杂度带来的问题。</u>**
  * 针对系统复杂点进行架构设计。
  * 架构设计并不需要面面俱到，有针对性的根据问题进行设计解决。
  * 对比自己业务复杂点，选择参考相似的方案。

**简单案例-大学学生管理系统**

* 需求：登录、注册、成绩管理、课程管理等。
* 性能分析：一个大学：1-2w人，平均每天每个学生访问次数约为1次左右, 性能不算分复杂。
  * 存储：mysql。
  * 缓存：暂不考虑。
  * web服务器：nginx代理转发。

* 可扩展性：学生管理系统功能稳定，扩展空间不大&扩展性不复杂。
* 高可用性：宕机 几小时，对学生管理工作影响不大，可以不做负载均衡，不考虑异地多活等复杂方案。
  * 若学生数据全部丢失，只能人工逐条修复，**需考虑存储高可靠**。**【复杂点-架构重点解决：数据库备份、机房备份】**
* 安全性：信息隐私【nginx提供ACL控制、用户账号密码管理、数据库访问权限控制】
* 成本：系统很简单，几台服务器就能够搞定，无需太多关注。

# 复杂度来源1-高性能

高性能复杂度来源：

* **单台计算机内部为了高性能带来的复杂度**
* **多台计算机集群为了高性能带来的复杂度**

## 单机复杂度

* 单机复杂度最关键点：操作系统。【操作系统发挥硬件性能，操作系统复杂度直接决定软件系统复杂度。】

* 操作系统和性能最相关点：**进程**和**线程**。

  * 进程：每个进程对应一个任务。每个任务有独立的内存空间，进程间互不相关，操作系统统一调度。
    * 多进程：CPU分时调度，已达到模拟多进程并行的作用。
    * 进程间通信：管道、消息队列、信号量、共享存储等。
  * 线程：解决单进程内部只能串行，不支持并行的问题，提高性能。
    * 线程：进程内部的子任务，进程中所有子任务共享进程的数据和资源。
    * 互斥锁：多线程中保证数据正确性-同一时间进程中只能有一个线程获得修改某数据的权限，A线程释放后，B线程才能继续申请修改。
    * **操作系统最小调度单位：线程**
    * **操作系统最小分配资源单位：进程**

  

  

  

  多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 种：SMP（Symmetric Multi-Processor，对称多处理器结构）、NUMA（Non-Uniform Memory Access，非一致存储访问结构）、MPP（Massive Parallel Processing，海量并行处理结构）。其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。

  操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术**并不是最新的就是最好的，也不是非此即彼的选择**。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。举一个最简单的例子：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。

* 

# 复杂度来源2-高可用

# 复杂度来源3-高

# 复杂度来源4-高

# 复杂度来源5-高

# 复杂度来源6-高


------

